{
  "readme_content": "# defi_ch: Cross-Chain Bridge Event Listener\n\nThis repository contains a Python-based simulation of a robust event listener and relayer, a critical component of a cross-chain bridge. This service monitors a source blockchain (e.g., Ethereum) for specific events, validates them, and relays the corresponding data to a destination chain.\n\n## Concept\n\nA cross-chain bridge allows users to transfer assets or data from one blockchain to another. A common mechanism for this is a \"lock-and-mint\" or \"lock-and-unlock\" model:\n\n1.  A user **locks** assets in a smart contract on the **source chain**.\n2.  This action emits an event (e.g., `TokensLocked`).\n3.  A network of relayers (or oracles) listens for this event.\n4.  Upon detecting a confirmed event, a relayer submits a transaction to the **destination chain** to mint or unlock an equivalent amount of a wrapped asset for the user.\n\nThis script simulates the **relayer** component (steps 3 and 4). It is designed to be resilient, stateful, and capable of handling blockchain-specific issues like network latency and chain reorganizations (reorgs).\n\n### Event Interface Example\n\nThe script is configured to listen for a specific event signature. For example, the source chain smart contract might define an event like this:\n\n```solidity\ninterface IBridge {\n    // Emitted when a user locks tokens on the source chain.\n    event TokensLocked(\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        bytes32 indexed destinationTxId\n    );\n}\n```\n\n## Code Architecture\n\nThe application is structured into several distinct classes, each with a single responsibility, to ensure modularity and maintainability.\n\n```\n+-------------------+      +-----------------------+      +-------------------+\n|   ConfigManager   |----->|   CrossChainRelayer   |<---->|      StateDB      |\n| (Loads .env)      |      |   (Orchestrator)      |      | (state.json)      |\n+-------------------+      +-----------+-----------+      +-------------------+\n                                       |\n                                       |\n                         +-------------v-------------+\n                         |       EventScanner        |\n                         | (Scans for contract events) |\n                         +-------------+-------------+\n                                       |\n                                       |\n                         +-------------v-------------+\n                         |    BlockchainConnector    |\n                         |      (Manages Web3)       |\n                         +---------------------------+\n```\n\n*   **`ConfigManager`**: Manages all configuration parameters. It loads settings like RPC URLs, contract addresses, and polling intervals from a `.env` file for security and flexibility.\n*   **`StateDB`**: Handles the persistence of the application's state. It saves the last successfully scanned block number to a JSON file (`state.json`), allowing the service to resume from where it left off after a restart.\n*   **`BlockchainConnector`**: Manages the connection to the source chain's RPC node using `web3.py`. It includes logic for checking connection status and attempting to reconnect if the connection is lost.\n*   **`EventScanner`**: The core component for blockchain interaction. It uses a `web3.py` contract instance to efficiently query a range of blocks for a specific event (`TokensLocked`).\n*   **`CrossChainRelayer`**: The main orchestrator. It coordinates the other components in a continuous loop:\n    1.  Determines the correct block range to scan, accounting for block confirmations and potential reorgs.\n    2.  Uses the `EventScanner` to fetch new events.\n    3.  Processes and validates each event.\n    4.  Relays the event data to the destination chain's API endpoint using the `requests` library.\n    5.  Instructs `StateDB` to save the new state upon successful processing of a batch of blocks.\n\n## How it Works\n\nThe service operates in an infinite loop, performing the following steps in each iteration:\n\n1.  **Get Chain State**: It connects to the source chain's RPC node and fetches the latest block number.\n2.  **Determine Scan Range**: It calculates a safe block range to scan.\n    *   The `to_block` is set to `latest_block_number - BLOCK_CONFIRMATIONS`. This ensures that we only process events from blocks that are unlikely to be reverted in a reorg.\n    *   The `from_block` is the last successfully scanned block (loaded from `state.json`), minus a safety margin to handle potential reorgs. On the very first run, it starts near the latest confirmed block.\n3.  **Scan for Events**: It queries the source chain for `TokensLocked` events within the calculated block range.\n4.  **Process and Relay**: If events are found, it iterates through them. Each event's data is formatted into a JSON payload and sent via a POST request to the destination chain's API endpoint.\n5.  **Update State**: After scanning the block range (whether events were found or not), it saves the `to_block` value to `state.json`. This marks the range as processed and ensures the next iteration starts from the correct position.\n6.  **Wait**: The service then pauses for a configurable interval (`POLL_INTERVAL_SECONDS`) before starting the next cycle.\n\nThis stateful design ensures that events are processed reliably and sequentially, resuming correctly even if the service is stopped and restarted.\n\n## Usage\n\n### 1. Prerequisites\n- Python 3.8+\n- An RPC URL for an Ethereum-compatible network (e.g., from [Infura](https://infura.io/) or [Alchemy](https://www.alchemy.com/)). This example is configured for the Sepolia testnet.\n\n### 2. Setup\n\nFirst, clone the repository:\n```bash\ngit clone https://github.com/your-username/defi_ch.git\ncd defi_ch\n```\n\nCreate a virtual environment and install the required dependencies:\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\npip install -r requirements.txt\n```\n\nCreate a `.env` file in the root directory and populate it with your configuration. You **must** replace the placeholder with the address of a deployed smart contract that you wish to monitor.\n\n```ini\n# .env file\n\n# RPC URL for the source blockchain (e.g., Ethereum Sepolia testnet)\nSOURCE_CHAIN_RPC_URL=\"https://rpc.ankr.com/eth_sepolia\"\n\n# The address of the bridge smart contract to monitor on the source chain\n# IMPORTANT: Replace the placeholder with a real contract address that emits a 'TokensLocked' event.\nBRIDGE_CONTRACT_ADDRESS=\"0xYourBridgeContractAddressHere\"\n\n# The API endpoint of the destination chain's relayer service\nDESTINATION_CHAIN_API_ENDPOINT=\"https://httpbin.org/post\" # Using httpbin.org for testing\n\n# Time in seconds between polling for new blocks\nPOLL_INTERVAL_SECONDS=15\n\n# Number of blocks to wait for finality before processing an event\nBLOCK_CONFIRMATIONS=6\n```\n\n### 3. Running the Script\n\nExecute the script from your terminal:\n```bash\npython script.py\n```\n\n### Example Output\n\nThe script will log its operations to the console.\n\n```\n2023-10-27 10:30:00,123 - INFO - Starting Cross-Chain Relayer Service...\n2023-10-27 10:30:01,456 - INFO - Successfully connected to blockchain node at https://rpc.ankr.com/eth_sepolia. Chain ID: 11155111, Latest Block: 4500100\n2023-10-27 10:30:01,457 - INFO - First run. Starting scan from block 4500094.\n2023-10-27 10:30:01,457 - INFO - Scanning for 'TokensLocked' events from block 4500094 to 4500094...\n2023-10-27 10:30:03,812 - INFO - Found 1 new 'TokensLocked' event(s).\n2023-10-27 10:30:03,813 - INFO - Relaying event with txId: 0x... to destination chain...\n2023-10-27 10:30:04,950 - INFO - Successfully relayed event 0x.... Destination API response: {...}\n2023-10-27 10:30:04,955 - INFO - State successfully saved to 'state.json'.\n2023-10-27 10:30:04,955 - DEBUG - Sleeping for 15 seconds...\n```\n"
}